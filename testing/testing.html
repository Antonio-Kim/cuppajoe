<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Testing</title>
</head>
<body>
  <header>
    <nav>
      <ul>
        <li><a href="../index.html">Home Page</a></li>
        <li><a href="../java/java-lang.html">Java Language</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <section id="basics">
      <p>
        The unit testing in Java is done with JUnit framework, hence both Maven and Gradle uses JUnit when it comes to testing. 
        However, there are other frameworks out there such as Spock or TestNG. When using either Maven or Gradle, two sections are
        created under src directory, which are /main and /test. Majority of your application code will go under main, but the testing
        codes will be under the /test directory. 
      </p>

      <p>
        So let's implement some simple unit tests. For now, we're going to work on unit testing and parameterized testing to get it going.
        As mentioned before, you'll write your code on src/main and write tests on src/test if you have setup your project using Maven or 
        Gradle. We'll add something simple to our main code:
        <pre>
          <code>
            public class Operations {
              public static void add(int a, int b) {
                return a + b;
              }
            }
          </code>
        </pre>
        Easy enough to understand. Now to test this, we would first check the correct input, then incorrect input(s), null, and etc, but for
        now we'll simply write one test that passes.
        <pre>
          <code>
            @Test
            @DisplayName("Checking correct addition")
            public void testCorrectAddition() {
              int a = 1;
              int b = 2;

              Assertions.assertEqual(Operations.add(a,b), 3);
            }
          </code>
        </pre>
        We're simply adding two numbers and checking if the output is correct. The codes will obviously more complicated, but this is not about 
        writing code. It's about writing unit tests. Now to run this test, open up the tab for Maven/Gradle in Intellij and go to 
        Tasks -> verification -> and click on test. This should run the whole tests you've setup under the test section.
      </p>
      <p>
        Let's now try parameterized test. We're continuing on with the add function we've written above, but we'll include parameters instead. 
        <pre>
          <code>
            @ParameterizedTest
            @CsvSource({
              "1, 2, 3",
              "4, 5, 9",
            })
            public void testMultipleAddition(int a, int b, int result) {
              Assertions.assertTrue(Operations.add(a,b) == result);
            }
          </code>
        </pre>
        Instead of assertEqual, we used assertTrue instead. Same as before, run the test from Maven/Gradle and you should expect the corrrect result. 
      </p>
      
      <p>
        <strong>Mocking</strong> is where you "mock" other dependencies such as database or other servers so that you test specifically the function
        or the class you are testing. Basically you create a dummy dependencies and getting it to behave similar to the real one.
      </p>
    </section>
    <section id="junit5">
      <h1>Core Concepts</h1>
      Here are main concepts of JUnit core:
      <ul>
        <li> A test class in JUnit 5 needs the following characteristics to run:</li>
          <ul>
            <li> It may be a top-level class, static member class, or inner class annotated as @Nested</li>
            <li> Must have single constructor, with no arguments, or arguments that can be dynamically resolved at runtime through </li>
            dependency injection
          </ul>
        <li> Test methods are annotated with: @Test, @Repeated-Test, @ParameterizedTest, @TestFactory, or @TestTemplate</li>
        <li> Lifecycle methods are annotated with: @BeforeAll, @AfterAll, @BeforeEach, @AfterEach</li>
        <li> TestInfo is a class whose objects are used to inject information about the currently executed test or container into @Test and all the lifecycle methods.
          TestInfo is added to constructor of the test clas (Reflection most likely).</li>
      </ul>

      <h2>Common Annotations in JUnit</h2>
      <ul>
        <li> @DisplayName: can be used over classes and methods. As name implies, whenever the test is ran, string inside the annotation is displayed.
          If a method is not displayed using @DisplayName, method name will be used instead. </li>
        <li> @Disabled: tells JUnit test method should not be executed. </li>
        <li> @Nested: usually tested on tightly coupled classes, such as inner and outer class. </li>
        <li> @RepeatedTest: repeats specified number of test to run. Annotation takes value and name as parameters. It can also use the following variables: </li>
          <ul>
            <li> displayName: current method name </li>
            <li> currentRepetition: how many times it has ran so far </li>
            <li> totalRepetition: specified in value parameter </li>
          </ul>
        <li> @ParameterizedTest: run multiple times with different arguments. Must declare at least one source providing the arguments for each invocation </li>
          <ul>
            <li> @ValueSource: single array of literal values. Each execution runs each elements of the array. </li>
            <li> @EnumSource </li>
            <li> @CsvSource: similar to ValuSource but with multiple inputs, separated by comma </li>
            <li> @CsvFileSource: instead of writing them on anntoation, it uses a csv file to run them. The file is replaced under /main/test/resources </li>
          </ul>
      </ul>

      <h2>Dynamic tests</h2>
      Dynamic test allows tests to be generated at runtime. To do so, we create a Factory method, and at runtime, it creates series of test to be run. Factory 
      method is created using @TestFactory. Remember that Factory method is NOT a test, but method that generate tests. It must one of the following:
      <ul>
        <li>DynamicNode</li>
        <li>Array of DynamicNode</li>
        <li>Stream of DynamicNode</li>
        <li>Collection of DynamicNode</li>
        <li>Iterable of DynamicNode</li>
        <li>ITerator of DynamicNode</li>
      </ul>
      <h3>Side notes</h3>
      <li> The assertAll method can be used in lambda function. This would allow chaining of multiple tests together.
    </section>
  </main>
</body>
</html>